"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[175],{88771:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"design/systems","title":"Systems","description":"An introduction to Systems in Planck","source":"@site/docs/design/systems.md","sourceDirName":"design","slug":"/design/systems","permalink":"/planck/docs/design/systems","draft":false,"unlisted":false,"editUrl":"https://github.com/YetAnotherClown/planck/edit/main/docs/design/systems.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Systems","description":"An introduction to Systems in Planck","sidebar_position":2},"sidebar":"defaultSidebar","previous":{"title":"Designing with Planck","permalink":"/planck/docs/design/"},"next":{"title":"Phases and Pipelines","permalink":"/planck/docs/design/phases-and-pipelines"}}');var r=t(74848),o=t(28453);const i={title:"Systems",description:"An introduction to Systems in Planck",sidebar_position:2},l="Systems",a={},d=[{value:"Single Responsibility",id:"single-responsibility",level:2},{value:"Self Contained",id:"self-contained",level:2},{value:"Aim for Generic, Reusable Systems",id:"aim-for-generic-reusable-systems",level:2},{value:"Application of these Principles",id:"application-of-these-principles",level:2},{value:"What&#39;s Next?",id:"whats-next",level:2}];function c(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"systems",children:"Systems"})}),"\n",(0,r.jsx)(n.p,{children:"When designing systems in ECS, we should be mindful of the composition of systems. In a system, we will usually perform queries;\r\nadd, modify, or remove data from our world, and or reconcile our data to Roblox's DataModel (such as parts in the Workspace)."}),"\n",(0,r.jsxs)(n.p,{children:["It's tempting to try and fit multiple different purposes into a system to make one huge system, but it is important to give\r\nsystems a ",(0,r.jsx)(n.em,{children:"single responsibility"}),", to make them small, and to isolate their behavior."]}),"\n",(0,r.jsx)(n.h2,{id:"single-responsibility",children:"Single Responsibility"}),"\n",(0,r.jsx)(n.p,{children:"You should design your systems to have a single responsibility. A system\r\nshould not do a lot of things, you should try and split up your systems\r\ninto smaller systems when you can."}),"\n",(0,r.jsx)(n.p,{children:"When you start out writing systems, you'll probably find yourself writing\r\nlarge systems that do many things. You can always go back and split up\r\nyour systems afterwards."}),"\n",(0,r.jsx)(n.h2,{id:"self-contained",children:"Self Contained"}),"\n",(0,r.jsx)(n.p,{children:"Systems should also be self-contained, with isolated behavior. They should\r\nbe designed to not depend on other systems. If we remove a system from\r\nour game, it should only remove the behavior declared in that system."}),"\n",(0,r.jsx)(n.h2,{id:"aim-for-generic-reusable-systems",children:"Aim for Generic, Reusable Systems"}),"\n",(0,r.jsx)(n.p,{children:"It's commonly said that using an ECS helps to create reusable code. This is\r\ntrue! Especially if you aim for single-responsibility systems and design\r\nthem to be generic."}),"\n",(0,r.jsx)(n.h2,{id:"application-of-these-principles",children:"Application of these Principles"}),"\n",(0,r.jsx)(n.p,{children:"Let's make a system first, and apply these principles after."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'local world = require("@shared/world")\r\nlocal scheduler = require("@shared/scheduler")\r\n\r\nlocal interval = require("@shared/interval")\r\nlocal throttle = interval(10)\r\n\r\nlocal Enemy = world:component()\r\nlocal Health = world:component()\r\nlocal Position = world:component()\r\nlocal Velocity = world:component()\r\n\r\nlocal function handleEnemies()\r\n    -- Spawn enemies every 10 seconds\r\n    if throttle() then\r\n        local entity = world:entity()\r\n\r\n        world:add(entity, Enemy)\r\n        world:set(entity, Health, 100)\r\n        world:set(entity, Position, Vector3.zero)\r\n        world:set(entity, Velocity, Vector3.new(1, 0, 1))\r\n    end\r\n\r\n    -- Move enemies every frame\r\n    for entity, position, velocity in\r\n        world:query(Position, Velocity):with(Enemy):iter()\r\n    do\r\n        local deltaTime = scheduler:getDeltaTime()\r\n\r\n        world:set(entity, Position, position * deltaTime * velocity)\r\n    end\r\n\r\n    -- Despawn enemies with 0 health\r\n    for entity, health in world:query(Health):with(Enemy):iter()\r\n        if health == 0 then\r\n            world:delete(entity)\r\n        end\r\n    end\r\nend\n'})}),"\n",(0,r.jsx)(n.p,{children:"This system handles our enemies in our game, it has 3 distinct responsibilities:\r\nspawning enemies, moving enemies, and despawning enemies."}),"\n",(0,r.jsx)(n.p,{children:"This system will get larger as we add more logic for our enemies, such as reconciling\r\nthe position to an actual model, adding cases where enemies may lose health, and other\r\nmechanics onto our enemies."}),"\n",(0,r.jsx)(n.p,{children:"We should split this system up into multiple, single responsibility systems."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'local world = require("@shared/world")\r\n\r\nlocal interval = require("@shared/interval")\r\nlocal throttle = interval(10)\r\n\r\nlocal Enemy = world:component()\r\nlocal Health = world:component()\r\nlocal Position = world:component()\r\nlocal Velocity = world:component()\r\n\r\nlocal function spawnEnemies()\r\n    -- Spawn enemies every 10 seconds\r\n    if throttle() then\r\n        local entity = world:entity()\r\n\r\n        world:add(entity, Enemy)\r\n        world:set(entity, Health, 100)\r\n        world:set(entity, Position, Vector3.zero)\r\n        world:set(entity, Velocity, Vector3.new(1, 0, 1))\r\n    end\r\nend\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'local world = require("@shared/world")\r\nlocal scheduler = require("@shared/scheduler")\r\n\r\nlocal Enemy = world:component()\r\nlocal Position = world:component()\r\nlocal Velocity = world:component()\r\n\r\nlocal function moveEnemies()\r\n    -- Move enemies every frame\r\n    for entity, position, velocity in\r\n        world:query(Position, Velocity):with(Enemy):iter()\r\n    do\r\n        local deltaTime = scheduler:getDeltaTime()\r\n\r\n        world:set(entity, Position, position * deltaTime * velocity)\r\n    end\r\nend\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'local world = require("@shared/world")\r\n\r\nlocal Enemy = world:component()\r\nlocal Health = world:component()\r\n\r\nlocal function despawnEnemies()\r\n    -- Despawn enemies with 0 health\r\n    for entity, health in world:query(Health):with(Enemy):iter()\r\n        if health == 0 then\r\n            world:delete(entity)\r\n        end\r\n    end\r\nend\n'})}),"\n",(0,r.jsx)(n.p,{children:"When designing systems, we should also think about reusability: how can you reuse a system in other parts of your game?"}),"\n",(0,r.jsxs)(n.p,{children:["Well, we might want to move other models besides just Enemies. We can redesign our ",(0,r.jsx)(n.code,{children:"moveEnemies"})," system to be generic."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'local world = require("@shared/world")\r\nlocal scheduler = require("@shared/scheduler")\r\n\r\nlocal Enemy = world:component()\r\nlocal Position = world:component()\r\nlocal Velocity = world:component()\r\n\r\nlocal function moveModels()\r\n    -- Move models every frame\r\n    for entity, position, velocity in\r\n        world:query(Position, Velocity):iter()\r\n    do\r\n        local deltaTime = scheduler:getDeltaTime()\r\n\r\n        world:set(entity, Position, position * deltaTime * velocity)\r\n    end\r\nend\n'})}),"\n",(0,r.jsx)(n.h2,{id:"whats-next",children:"What's Next?"}),"\n",(0,r.jsx)(n.p,{children:"Now that we know how to design Systems, we should learn more about Phase and Pipelines."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>l});var s=t(96540);const r={},o=s.createContext(r);function i(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);